<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PROJECT grafkom</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.153.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.153.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { Octree } from 'three/addons/math/Octree.js';
        import { Capsule } from 'three/addons/math/Capsule.js';
        import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';

        // utils, helper
        import { getCenterOBJ, getBoundaryHWD } from "./helper.js"
        import { setupLighting } from "./lighting.js"

        // INITIAL SETUP
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 0);
        camera.rotation.order = 'YXZ';
        const loader = new GLTFLoader();
        const clock = new THREE.Clock();
        const textureLoader = new THREE.TextureLoader();


        const GRAVITY = 30;
        const STEPS_PER_FRAME = 5;
        // player collider
        const worldOctree = new Octree();
        const playerCollider = new Capsule(new THREE.Vector3(0, 0.05, 0), new THREE.Vector3(0, 10, 0), 0.35);
        const playerVelocity = new THREE.Vector3();
        const playerDirection = new THREE.Vector3();

        let playerOnFloor = false;

        const renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0x000000);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.VSMShadowMap;
        document.body.appendChild(renderer.domElement);

        const control = new PointerLockControls(camera, renderer.domElement)


        // CENTER LIGHTING

        // buat cube invisible supaya spotlight targetnya ke cube terus
        const cube = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
        cube.visible = false;
        scene.add(cube);
        function updateObjectPosition() {
            const vector = new THREE.Vector3(0, 0, -10);
            vector.applyMatrix4(camera.matrixWorld);
            cube.position.copy(vector);
        }
        function updateSpotlightPosition() {
            // buat supaya spotlight berada di depan camera
            const offsetDistance = 0;
            const offset = new THREE.Vector3(0, 0, -offsetDistance);
            offset.applyQuaternion(camera.quaternion);
            spotlight.position.copy(camera.position).add(offset);

            // buat ngarahin target spotlight ke posisi cube yang invisible
            spotlight.target.position.copy(cube.position);
            spotlight.target.updateMatrixWorld();
        }

        let wideSpotlight = false;
        const spotlight = new THREE.SpotLight(0xffffff, 2);
        spotlight.position.set(0, 5, 10);
        spotlight.angle = Math.PI / 16;
        spotlight.penumbra = 0.1;
        spotlight.decay = 0.1;
        spotlight.distance = 150;

        spotlight.shadow.mapSize.width = 2048; // Meningkatkan resolusi shadow map
        spotlight.shadow.mapSize.height = 2048;
        spotlight.shadow.bias = -0.0001;

        spotlight.castShadow = true;
        scene.add(spotlight);

        // LIGHTING
        setupLighting(scene, camera)

        // EVENT HANDLING
        let keyboard = {};
        document.addEventListener('keydown', function (event) {
            keyboard[event.key] = true;
        });
        document.addEventListener('keyup', function (event) {
            keyboard[event.key] = false;
        });

        // movement handling
        let jump = false;
        function controls(deltaTime) {
            const speedDelta = deltaTime * (playerOnFloor ? 20 : 5) + 0.1;
            if (keyboard['W'] || keyboard['w']) {
                playerVelocity.add(getForwardVector().multiplyScalar(speedDelta));
                updateBobbing();
            }
            if (keyboard['a'] || keyboard['A']) {
                playerVelocity.add(getSideVector().multiplyScalar(- speedDelta)); updateBobbing();
            }
            if (keyboard['s'] || keyboard['S']) {
                playerVelocity.add(getForwardVector().multiplyScalar(- speedDelta)); updateBobbing();
            }
            if (keyboard['d'] || keyboard['D']) {
                playerVelocity.add(getSideVector().multiplyScalar(speedDelta)); updateBobbing();
            }
            if (keyboard['r'] || keyboard['R']) {
                spotlight.visible = !spotlight.visible;
            }
            if (keyboard['t'] || keyboard['T']) {
                if (wideSpotlight == false) {
                    spotlight.angle = Math.PI / 4;
                    wideSpotlight = true;
                } else {
                    spotlight.angle = Math.PI / 16;
                    wideSpotlight = false;
                }
            }
            if (playerOnFloor) {
                if (keyboard['v']) {
                    jump = true;
                    playerVelocity.y = 15;
                }
            }
        }

        function updateBobbing() {
            if (playerOnFloor) {
                playerVelocity.y = 3;
            }
        }

        // LOAD MODELS
        let alas, rumah, pintuUtama, streetLamp1, streetLamp2, kipas, sofa, longTable;
        function objShadow(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        }
        async function loadModels() {
            try {
                // load alas
                const textureAlas = textureLoader.load("./public/grass.jpg");
                textureAlas.wrapS = THREE.RepeatWrapping;
                textureAlas.wrapT = THREE.RepeatWrapping;
                textureAlas.repeat.set(10, 10);
                const alas_geometry = new THREE.BoxGeometry(250, 1, 250);
                const alas_material = new THREE.MeshStandardMaterial({ map: textureAlas });
                alas = new THREE.Mesh(alas_geometry, alas_material);
                alas.position.set(0, 0, -80);

                scene.add(alas);
                worldOctree.fromGraphNode(alas);


                // load rumah
                const ruanganPromise = new Promise((resolve, reject) => {
                    loader.load('./public/rumah.glb', function (gltf) {
                        rumah = gltf.scene;
                        rumah.scale.set(10, 10, 10)
                        rumah.position.set(0, 0, 0);

                        rumah.traverse(objShadow);

                        scene.add(rumah);
                        worldOctree.fromGraphNode(rumah);
                        resolve();
                    }, undefined, reject);
                });
                await ruanganPromise;

                // load pintu depan
                const pintuPromise = new Promise((resolve, reject) => {
                    loader.load('./public/pintuDepan.glb', function (gltf) {
                        pintuUtama = gltf.scene;
                        pintuUtama.scale.set(10, 10, 10)
                        pintuUtama.position.set(-44, 6.5, -70);

                        pintuUtama.traverse(objShadow);

                        scene.add(pintuUtama);
                        resolve();
                    }, undefined, reject);
                });
                await ruanganPromise;

                // load street lamp 1
                const streetlamp1Promise = new Promise((resolve, reject) => {
                    loader.load('./public/street_lamp.glb', function (gltf) {
                        streetLamp1 = gltf.scene;
                        streetLamp1.scale.set(10, 15, 10)
                        streetLamp1.position.set(-20, -6, -60);

                        streetLamp1.traverse(objShadow);

                        scene.add(streetLamp1);
                        resolve();
                    }, undefined, reject);
                });
                await streetlamp1Promise;

                // load street lamp 2
                const streetlamp2Promise = new Promise((resolve, reject) => {
                    loader.load('./public/street_lamp.glb', function (gltf) {
                        streetLamp2 = gltf.scene;
                        streetLamp2.scale.set(10, 15, 10)
                        streetLamp2.position.set(-120, -6, -60);

                        streetLamp2.traverse(objShadow);

                        scene.add(streetLamp2);
                        resolve();
                    }, undefined, reject);
                });
                await streetlamp1Promise;

                // load kipas
                const kipasPromise = new Promise((resolve, reject) => {
                    loader.load('./public/simple_ceiling_fan.glb', function (gltf) {
                        kipas = gltf.scene;
                        kipas.scale.set(0.02, 0.01, 0.02)
                        let center = getCenterOBJ(kipas);
                        kipas.position.set(-18, 35.5, -88);

                        kipas.traverse(objShadow);

                        scene.add(kipas);
                        resolve();
                    }, undefined, reject);
                })
                await kipasPromise;

                // load sofa
                const sofaPromise = new Promise((resolve, reject) => {
                    loader.load('./public/sofa.glb', function (gltf) {
                        sofa = gltf.scene;
                        sofa.scale.set(0.1, 0.1, 0.1)
                        sofa.rotation.y = Math.PI;
                        sofa.position.set(-25, 6.5, -88);

                        sofa.traverse(objShadow);

                        worldOctree.fromGraphNode(sofa);
                        scene.add(sofa);
                        resolve();
                    }, undefined, reject);
                })
                await sofaPromise;

                // load long table  
                const longTablePromise = new Promise((resolve, reject) => {
                    loader.load('./public/long_table.glb', function (gltf) {
                        longTable = gltf.scene;
                        longTable.position.set(-3.5, 6, -88);

                        longTable.traverse(objShadow);

                        worldOctree.fromGraphNode(longTable);
                        scene.add(longTable);
                        resolve();
                    }, undefined, reject);
                })
                await longTablePromise;

                //

                await Promise.all([ruanganPromise, streetlamp1Promise, streetlamp2Promise, kipasPromise, sofaPromise, longTablePromise]);
            } catch (error) {
                console.log("Error loading models : " + error);
            }
        }
        loadModels();

        // COLLISION
        function playerCollisions() {
            const result = worldOctree.capsuleIntersect(playerCollider);
            playerOnFloor = false;
            if (result) {
                playerOnFloor = result.normal.y > 0;
                if (!playerOnFloor) {
                    playerVelocity.addScaledVector(result.normal, - result.normal.dot(playerVelocity));
                }
                playerCollider.translate(result.normal.multiplyScalar(result.depth));
            }
        }
        // buat update player letaknya
        function updatePlayer(deltaTime) {
            let damping = Math.exp(- 4 * deltaTime) - 1;
            if (!playerOnFloor) {
                if (jump) {
                    playerVelocity.y -= GRAVITY * deltaTime;
                    damping *= 0.01;
                } else {
                    playerVelocity.y -= GRAVITY * deltaTime * 0.5;
                }
            }

            playerVelocity.addScaledVector(playerVelocity, damping);
            const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
            playerCollider.translate(deltaPosition);
            playerCollisions();
            camera.position.copy(playerCollider.end);
        }
        // dapetin vector arah setelah normalisasi
        function getForwardVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            return playerDirection;
        }
        function getSideVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            playerDirection.cross(camera.up);
            return playerDirection;
        }

        // ANIMATE
        let openPintuUtama = false;
        function bukaPintuUtama() {
            if (pintuUtama) {
                if (openPintuUtama) {
                    let boundary = getBoundaryHWD(pintuUtama);
                    console.log(boundary)
                    pintuUtama.position.set(-48, 6.5, -75);
                    pintuUtama.rotation.set(0, Math.PI / 2, 0);
                } else {
                    pintuUtama.position.set(-44, 6.5, -70);
                    pintuUtama.rotation.set(0, 0, 0);
                }
            }
        }
        function animate() {
            requestAnimationFrame(animate);

            updateSpotlightPosition();
            updateObjectPosition();

            const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;
            for (let i = 0; i < STEPS_PER_FRAME; i++) {
                controls(deltaTime);
                updatePlayer(deltaTime);
                if (playerOnFloor) {
                    jump = false;
                }
            }
            console.log(camera.position);
            control.lock();

            // animasi kipas
            if (kipas) kipas.rotation.y += 0.1;

            // animasi buka pintu utama
            if (camera.position.x >= -55 && camera.position.x <= -30 && camera.position.z >= -90 && camera.position.z <= -50) {
                openPintuUtama = true;
            } else {
                openPintuUtama = false;
            }
            bukaPintuUtama();


            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>

</html>