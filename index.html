<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PROJECT grafkom</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <div class="mainInfoBox">
        <span class="mainInfoText"><b>Kordinat : </b><span id="kordinat"></span></span>
        <span class="mainInfoText"><b>Can Interact : </b><span class="interactFalse" style="font-weight: bold;"
                id="interactinfo">FALSE</span></span>
    </div>
    <video id="video_ww" style="display: none;"></video>
    <div id="alert-container"></div>
    <div class="inventory-container">
        <div class="inventory-box" id="item1">
            <img src="https://via.placeholder.com/50" alt="">
        </div>
        <div class="inventory-box" id="item2">
            <img src="https://via.placeholder.com/50" alt="">
        </div>
        <div class="inventory-box" id="item3">
            <img src="https://via.placeholder.com/50" alt="">
        </div>
        <div class="inventory-box" id="item4">
            <img src="https://via.placeholder.com/50" alt="">
        </div>
        <div class="inventory-box" id="item5">
            <img src="https://via.placeholder.com/50" alt="">
        </div>
    </div>
    <div class="crosshair">
        <div class="vertical"></div>
        <div class="horizontal"></div>
        <div class="focus-indicator">press<span class="characterHighlight"> F </span> to interact</div>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.153.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.153.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        // #region UI HTML
        let kordinatspan = document.getElementById("kordinat");
        let interactinfospan = document.getElementById("interactinfo");
        function setInventoryItem(itemIndex, imageUrl) {
            var inventoryBox = document.getElementById('item' + itemIndex);
            var img = inventoryBox.querySelector('img');

            if (imageUrl) {
                img.src = imageUrl;
                inventoryBox.style.backgroundColor = ''; // Remove background color if image exists
                img.style.width = '50px'; // Force image width to 50px
                img.style.height = '50px'; // Force image height to 50px
            } else {
                img.src = ''; // Clear the image if no image URL provided
                inventoryBox.style.backgroundColor = '#ccc'; // Set background color for empty box
            }
        }
        document.addEventListener('keypress', function (event) {
            var key = event.key;
            var inventoryIndex = parseInt(key);
            // Highlight the inventory item if valid key pressed
            if (inventoryIndex >= 1 && inventoryIndex <= 5) {
                var inventoryItem = document.getElementById('item' + inventoryIndex);
                inventoryItem.classList.add('highlight');
                selectedInventory = inventoryIndex - 1;
                console.log(selectedInventory);
                console.log(inventoryList[selectedInventory])
                // Remove highlight from all other inventory items
                var inventoryItems = document.querySelectorAll('.inventory-box');
                inventoryItems.forEach(function (item) {
                    if (item !== inventoryItem) {
                        item.classList.remove('highlight');
                    }
                });
            }
        });

        setInventoryItem(1, 'https://via.placeholder.com/100');
        setInventoryItem(2, 'https://via.placeholder.com/100');
        setInventoryItem(3, 'https://via.placeholder.com/100');
        setInventoryItem(4, 'https://via.placeholder.com/100');
        setInventoryItem(5, 'https://via.placeholder.com/100');
        // #endregion 

        // #region IMPORT LIBRARY & FILE
        import * as THREE from 'three';
        import * as TWEEN from '@tweenjs/tween.js'
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { Octree } from 'three/addons/math/Octree.js';
        import { Capsule } from 'three/addons/math/Capsule.js';
        import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';
        // utils, helper
        import { checkUpdateIntersect } from "./game.js";
        import { getCenterOBJ, getBoundaryHWD, showAlert, createCollisionCube } from "./helper.js"
        import { setupLighting } from "./lighting.js"
        // #endregion

        // #region VARIABLE & SETUP
        const scene = new THREE.Scene();
        const raycaster = new THREE.Raycaster();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 0);
        camera.rotation.order = 'YXZ';
        const loader = new GLTFLoader();
        const clock = new THREE.Clock();
        const textureLoader = new THREE.TextureLoader();

        // player component
        const GRAVITY = 30;
        const STEPS_PER_FRAME = 5;
        const worldOctree = new Octree();
        const playerCollider = new Capsule(new THREE.Vector3(0, 0.05, 0), new THREE.Vector3(0, 10, 0), 0.35);
        const playerVelocity = new THREE.Vector3();
        const playerDirection = new THREE.Vector3();
        let playerOnFloor = false;

        // interact & game component
        let video, videoOn = false;
        const alertContainer = document.getElementById('alert-container');

        const renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0x000000);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.VSMShadowMap;
        document.body.appendChild(renderer.domElement);
        const control = new PointerLockControls(camera, renderer.domElement)

        // inventory list
        let selectedInventory = null;
        let inventoryList = [false, false, false, false]
        // #endregion

        // #region CENTER LIGHTING
        let wideSpotlight = false;
        const cube = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
        cube.visible = false;
        scene.add(cube);
        function updateObjectPosition() {
            const vector = new THREE.Vector3(0, 0, -10);
            vector.applyMatrix4(camera.matrixWorld);
            cube.position.copy(vector);
        }
        function updateSpotlightPosition() {
            // buat supaya spotlight berada di depan camera
            const offsetDistance = 0;
            const offset = new THREE.Vector3(0, 0, -offsetDistance);
            offset.applyQuaternion(camera.quaternion);
            spotlight.position.copy(camera.position).add(offset);

            // buat ngarahin target spotlight ke posisi cube yang invisible
            spotlight.target.position.copy(cube.position);
            spotlight.target.updateMatrixWorld();
        }

        const spotlight = new THREE.SpotLight(0xffffff, 2);
        spotlight.position.set(0, 5, 10);
        spotlight.angle = Math.PI / 16;
        spotlight.penumbra = 0.1;
        spotlight.decay = 0.1;
        spotlight.distance = 150;

        spotlight.shadow.mapSize.width = 2048; // Meningkatkan resolusi shadow map
        spotlight.shadow.mapSize.height = 2048;
        spotlight.shadow.bias = -0.0001;

        spotlight.castShadow = true;
        scene.add(spotlight);
        // #endregion

        // #region OTHER LIGHTING
        setupLighting(scene, camera)
        // lighting yang nyala dengan kondisi tertentu
        const garageLight = new THREE.PointLight(0xffffff, 500, 1000, 2);
        garageLight.position.set(57, 25, -70);
        garageLight.castShadow = true;
        scene.add(garageLight);
        garageLight.shadow.mapSize.width = 2048;
        garageLight.shadow.mapSize.height = 2048;
        garageLight.shadow.bias = -0.005;

        //disco
        const discoLamp = new THREE.PointLight(0xffffff, 500, 1000, 2.5);
        discoLamp.position.set(-70, 25, -88)
        discoLamp.castShadow = true;
        discoLamp.shadow.mapSize.width = 2048;
        discoLamp.shadow.mapSize.height = 2048;
        discoLamp.shadow.bias = -0.005;
        scene.add(discoLamp)
        // #endregion

        // #region EVENT HANDLING
        let keyboard = {};
        document.addEventListener('keydown', function (event) {
            keyboard[event.key] = true;
        });
        document.addEventListener('keyup', function (event) {
            keyboard[event.key] = false;
        });

        // movement handling
        let jump = false;
        function controls(deltaTime) {
            const speedDelta = deltaTime * (playerOnFloor ? 20 : 5) + 0.1;
            if (keyboard['W'] || keyboard['w']) {
                playerVelocity.add(getForwardVector().multiplyScalar(speedDelta));
            }
            if (keyboard['a'] || keyboard['A']) {
                playerVelocity.add(getSideVector().multiplyScalar(- speedDelta));
            }
            if (keyboard['s'] || keyboard['S']) {
                playerVelocity.add(getForwardVector().multiplyScalar(- speedDelta));
            }
            if (keyboard['d'] || keyboard['D']) {
                playerVelocity.add(getSideVector().multiplyScalar(speedDelta));
            }
            if (playerOnFloor) {
                if (keyboard[' ']) {
                    jump = true;
                    playerVelocity.y = 15;
                }
            }
        }
        function specialControl() {
            if (keyboard['r'] || keyboard['R']) {
                spotlight.visible = !spotlight.visible;
            }
            if (keyboard['t'] || keyboard['T']) {
                if (wideSpotlight == false) {
                    spotlight.angle = Math.PI / 4;
                    wideSpotlight = true;
                } else {
                    spotlight.angle = Math.PI / 16;
                    wideSpotlight = false;
                }
            }
        }
        // #endregion

        // #region LOAD MODELS & VIDEO
        let alas, rumah, pintuUtama, streetLamp1,
            streetLamp2, kipas, sofa, longTable,
            bulan, kasur, pigura, mazda, glight,
            radio, radioTable, disco, television,
            bedroomTable, tape1, lemari, tape2, tape3,
            rak_0, rak_2, rak_3, pintu1, pintu2, pintu3;
        let rak_0_open = 1, rak_2_open = 1, rak_3_open = 1;
        let tapeMaterial, radioMaterial, rakMaterial;

        function objShadow(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        }
        async function loadModels() {
            try {
                // load alas
                const textureAlas = textureLoader.load("./public/grass.jpg");
                textureAlas.wrapS = THREE.RepeatWrapping;
                textureAlas.wrapT = THREE.RepeatWrapping;
                textureAlas.repeat.set(10, 10);
                const alas_geometry = new THREE.BoxGeometry(250, 1, 250);
                const alas_material = new THREE.MeshStandardMaterial({ map: textureAlas });
                alas = new THREE.Mesh(alas_geometry, alas_material);
                alas.position.set(0, 0, -80);

                scene.add(alas);
                worldOctree.fromGraphNode(alas);

                // load rumah
                const ruanganPromise = new Promise((resolve, reject) => {
                    loader.load('./public/rumah.glb', function (gltf) {
                        rumah = gltf.scene;
                        rumah.scale.set(10, 10, 10)
                        rumah.position.set(0, 0, 0);
                        rumah.traverse(objShadow);

                        scene.add(rumah);
                        worldOctree.fromGraphNode(rumah);
                        resolve();
                    }, undefined, reject);
                });
                await ruanganPromise;

                // load pintu depan
                const pintuPromise = new Promise((resolve, reject) => {
                    loader.load('./public/pintuDepan.glb', function (gltf) {
                        pintuUtama = gltf.scene;
                        pintuUtama.scale.set(10, 10, 10)
                        pintuUtama.position.set(-44, 6.5, -70);
                        pintuUtama.traverse(objShadow);
                        scene.add(pintuUtama);
                        resolve();
                    }, undefined, reject);
                });
                await pintuPromise;

                const pintu1Promise = new Promise((resolve, reject) => {
                    loader.load('./public/pintuDepan.glb', function (gltf) {
                        pintu1 = gltf.scene;
                        pintu1.scale.set(9, 9.5, 10)
                        pintu1.position.set(-59, 6.5, -105.5);
                        pintu1.traverse(objShadow);
                        scene.add(pintu1);
                        resolve();
                    }, undefined, reject);
                });
                await pintu1Promise;

                const pintu2Promise = new Promise((resolve, reject) => {
                    loader.load('./public/pintuDepan.glb', function (gltf) {
                        pintu2 = gltf.scene;
                        pintu2.scale.set(9, 9.5, 10)
                        pintu2.position.set(-59, 6.5, -140);
                        pintu2.traverse(objShadow);
                        scene.add(pintu2);
                        resolve();
                    }, undefined, reject);
                });
                await pintu2Promise;

                const pintu3Promise = new Promise((resolve, reject) => {
                    loader.load('./public/pintuDepan.glb', function (gltf) {
                        pintu3 = gltf.scene;
                        pintu3.scale.set(10.1, 9.5, 10)
                        pintu3.position.set(35.63, 6.5, -105.5);
                        pintu3.traverse(objShadow);
                        scene.add(pintu3);
                        resolve();
                    }, undefined, reject);
                });
                await pintu3Promise;

                // load street lamp 1
                const streetlamp1Promise = new Promise((resolve, reject) => {
                    loader.load('./public/street_lamp.glb', function (gltf) {
                        streetLamp1 = gltf.scene;
                        streetLamp1.scale.set(10, 15, 10)
                        streetLamp1.position.set(-20, -6, -60);
                        streetLamp1.traverse(objShadow);
                        scene.add(streetLamp1);
                        resolve();
                    }, undefined, reject);
                });
                await streetlamp1Promise;

                // load street lamp 2
                const streetlamp2Promise = new Promise((resolve, reject) => {
                    loader.load('./public/street_lamp.glb', function (gltf) {
                        streetLamp2 = gltf.scene;
                        streetLamp2.scale.set(10, 15, 10)
                        streetLamp2.position.set(-120, -6, -60);
                        streetLamp2.traverse(objShadow);
                        scene.add(streetLamp2);
                        resolve();
                    }, undefined, reject);
                });
                await streetlamp1Promise;

                // load kipas
                const kipasPromise = new Promise((resolve, reject) => {
                    loader.load('./public/simple_ceiling_fan.glb', function (gltf) {
                        kipas = gltf.scene;
                        kipas.scale.set(0.02, 0.01, 0.02)
                        kipas.position.set(-18, 35.5, -88);
                        kipas.traverse(objShadow);
                        scene.add(kipas);
                        resolve();
                    }, undefined, reject);
                })
                await kipasPromise;

                // load sofa
                const sofaPromise = new Promise((resolve, reject) => {
                    loader.load('./public/sofa.glb', function (gltf) {
                        sofa = gltf.scene;
                        sofa.scale.set(0.1, 0.1, 0.1)
                        sofa.rotation.y = Math.PI;
                        sofa.position.set(-25, 6.5, -88);
                        sofa.traverse(objShadow);

                        createCollisionCube(sofa, worldOctree, scene)
                        scene.add(sofa);
                        resolve();
                    }, undefined, reject);
                })
                await sofaPromise;

                // load long table  
                const longTablePromise = new Promise((resolve, reject) => {
                    loader.load('./public/long_table.glb', function (gltf) {
                        longTable = gltf.scene;
                        longTable.position.set(-3.5, 6, -88);
                        longTable.traverse(objShadow);

                        createCollisionCube(longTable, worldOctree, scene);
                        scene.add(longTable);
                        resolve();
                    }, undefined, reject);
                })
                await longTablePromise;

                // load bulan
                const bulanPromise = new Promise((resolve, reject) => {
                    loader.load('./public/the_moon.glb', function (gltf) {
                        bulan = gltf.scene;
                        bulan.scale.set(10, 10, 10);
                        bulan.position.set(-100, 300, -100);
                        bulan.traverse(objShadow);
                        scene.add(bulan);
                        resolve();
                    }, undefined, reject);
                })
                await bulanPromise;

                // load bed
                const kasurPromise = new Promise((resolve, reject) => {
                    loader.load('./public/bed.glb', function (gltf) {
                        kasur = gltf.scene;
                        kasur.position.set(-78, 6, -168);
                        kasur.scale.set(3, 3, 3);
                        kasur.rotation.y = Math.PI / 2;
                        kasur.traverse(objShadow);

                        createCollisionCube(kasur, worldOctree, scene);
                        scene.add(kasur);
                        resolve();
                    }, undefined, reject);
                })
                await kasurPromise;

                // load  picture frame
                const piguraPromise = new Promise((resolve, reject) => {
                    loader.load('./public/picture.glb', function (gltf) {
                        pigura = gltf.scene;
                        pigura.position.set(-88, 15, -160);
                        pigura.scale.set(1.5, 1.5, 1.5)
                        pigura.rotation.y = Math.PI / 2;
                        pigura.traverse(objShadow);
                        scene.add(pigura);
                        resolve();
                    }, undefined, reject);
                })
                await piguraPromise;

                // load garage light
                const glightPromise = new Promise((resolve, reject) => {
                    loader.load('./public/garage_light.glb', function (gltf) {
                        glight = gltf.scene;
                        glight.position.set(57, 31.85, -70);
                        glight.scale.set(0.01, 0.01, 0.01)
                        glight.traverse(objShadow);
                        scene.add(glight);
                        resolve();
                    }, undefined, reject);
                })
                await glightPromise;

                //load radioTable 
                const radioTablePromise = new Promise((resolve, reject) => {
                    loader.load('./public/table.glb', function (gltf) {
                        radioTable = gltf.scene;
                        radioTable.traverse(objShadow);
                        radioTable.scale.set(2.6, 2.6, 2.6);
                        radioTable.position.set(-70, 7, -88);
                        createCollisionCube(radioTable, worldOctree, scene)
                        scene.add(radioTable);
                        resolve();
                    }, undefined, reject);
                })
                await radioTablePromise

                //load radio
                const radioPromise = new Promise((resolve, reject) => {
                    loader.load('./public/radio_vef202.glb', function (gltf) {
                        radio = gltf.scene;
                        radio.traverse(objShadow);
                        radio.scale.set(1.5, 1.5, 1.5);
                        radio.position.set(-70, 15, -88);
                        radio.rotation.y = Math.PI;
                        radio.traverse(function (child) {
                            if (child.isMesh) {
                                radioMaterial = child.material;
                            }
                        });
                        scene.add(radio);
                        resolve();
                    }, undefined, reject);
                })
                await radioPromise

                // load disco lamp
                const discoPromise = new Promise((resolve, reject) => {
                    loader.load('./public/garage_light.glb', function (gltf) {
                        disco = gltf.scene;
                        disco.scale.set(0.01, 0.01, 0.01);
                        disco.position.set(-70, 31.85, -88);
                        disco.traverse(objShadow);
                        scene.add(disco);
                        resolve();
                    }, undefined, reject);
                })
                await discoPromise

                // load television
                const televisionPromise = new Promise((resolve, reject) => {
                    loader.load('./public/television.glb', function (gltf) {
                        television = gltf.scene;
                        television.name = "television"
                        television.traverse(objShadow)
                        television.scale.set(20, 20, 20);
                        television.rotation.y = -Math.PI / 2;
                        television.position.set(-5, 12.25, -88);
                        scene.add(television);
                        resolve();
                    }, undefined, reject);
                })
                await televisionPromise

                // load bedroom table
                const bedroomTablePromise = new Promise((resolve, reject) => {
                    loader.load('./public/table.glb', function (gltf) {
                        bedroomTable = gltf.scene;
                        bedroomTable.traverse(objShadow);
                        bedroomTable.scale.set(2.6, 2.3, 2.6);
                        bedroomTable.position.set(-80, 7, -150);
                        createCollisionCube(bedroomTable, worldOctree, scene)
                        scene.add(bedroomTable);
                        resolve();
                    }, undefined, reject);
                })
                await bedroomTablePromise

                // load tape 1
                const tape1Promise = new Promise((resolve, reject) => {
                    loader.load('./public/tape_1.glb', function (gltf) {
                        tape1 = gltf.scene;
                        tape1.name = "tape1";
                        tape1.traverse(objShadow);
                        tape1.scale.set(26, 26, 26);
                        tape1.position.set(-80, 14.5, -150);
                        tape1.traverse(function (child) {
                            if (child.isMesh) {
                                tapeMaterial = child.material;
                            }
                        });

                        scene.add(tape1);
                        resolve();
                    }, undefined, reject);
                })
                await tape1Promise

                const tape2Promise = new Promise((resolve, reject) => {
                    loader.load('./public/tape_2.glb', function (gltf) {
                        tape2 = gltf.scene;
                        tape2.name = "tape2";
                        tape2.traverse(objShadow);
                        tape2.scale.set(26, 26, 26);
                        tape2.position.set(5, 16.6, -130);

                        scene.add(tape2);
                        resolve();
                    }, undefined, reject);
                })
                await tape2Promise

                // load lemari
                const lemariPromise = new Promise((resolve, reject) => {
                    loader.load('./public/lemari.glb', function (gltf) {
                        lemari = gltf.scene;
                        lemari.traverse(objShadow);
                        lemari.scale.set(9, 9, 9);
                        lemari.position.set(15, 6.5, -85);
                        lemari.rotation.y = Math.PI / 2;

                        // simpen per component lemarinya
                        rak_0 = lemari.getObjectByName("rak_0");
                        rak_2 = lemari.getObjectByName("rak_2");
                        rak_3 = lemari.getObjectByName("rak_3");

                        rak_0.traverse(function (child) {
                            if (child.isMesh) {
                                rakMaterial = child.material;
                            }
                        });

                        createCollisionCube(lemari, worldOctree, scene)
                        scene.add(lemari);
                        resolve();
                    }, undefined, reject);
                })
                await lemariPromise

                await Promise.all([pintu1Promise, pintu2Promise, pintu3Promise, lemariPromise, 
                    tape1Promise, bedroomTablePromise, ruanganPromise, streetlamp1Promise, streetlamp2Promise,
                    kipasPromise, sofaPromise, longTablePromise, kasurPromise,
                    piguraPromise, glightPromise, radioTablePromise, discoPromise,
                    radioPromise, televisionPromise]);
                // add interactable object;
                interactableObject.push(television, tape1, tape2, radio, rak_0, rak_2, rak_3)
            } catch (error) {
                console.log("Error loading models : " + error);
            }
        }
        loadModels();
        // load vidio
        video = document.getElementById('video_ww')
        video.src = "public/wutheringwaves.mp4";
        video.muted = false;
        video.loop = false;
        let videoTexture = new THREE.VideoTexture(video);
        const geoLayar = new THREE.PlaneGeometry(2.2255, 1.245); // param1 : lebar, param2 : tinggi unitnya
        const mpmLayar = new THREE.MeshBasicMaterial({ map: videoTexture });
        const layar = new THREE.Mesh(geoLayar, mpmLayar);
        layar.position.set(-5.7, 18.5, -88.25)
        layar.scale.set(7.3, 7.8, 8)
        layar.rotation.set(0, -Math.PI / 2, 0)
        scene.add(layar);

        // #endregion

        // #region COLLISION
        function playerCollisions() {
            const result = worldOctree.capsuleIntersect(playerCollider);
            playerOnFloor = false;
            if (result) {
                playerOnFloor = result.normal.y > 0;
                if (!playerOnFloor) {
                    playerVelocity.addScaledVector(result.normal, - result.normal.dot(playerVelocity));
                }
                playerCollider.translate(result.normal.multiplyScalar(result.depth));
            }
        }
        // buat update player letaknya
        function updatePlayer(deltaTime) {
            let damping = Math.exp(- 4 * deltaTime) - 1;
            if (!playerOnFloor) {
                if (jump) {
                    playerVelocity.y -= GRAVITY * deltaTime;
                    damping *= 0.01;
                } else {
                    playerVelocity.y -= GRAVITY * deltaTime * 0.5;
                }
            }

            playerVelocity.addScaledVector(playerVelocity, damping);
            const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
            playerCollider.translate(deltaPosition);
            playerCollisions();
            camera.position.copy(playerCollider.end);
        }
        // dapetin vector arah setelah normalisasi
        function getForwardVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            return playerDirection;
        }
        function getSideVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            playerDirection.cross(camera.up);
            return playerDirection;
        }
        // #endregion

        // #region ANIMATION
        let openPintuUtama = false;
        let openPintu1 = false, openPintu2 = false, openPintu3 = false;

        // animasi buka pintu
        function bukaPintuUtama() {
            if (pintuUtama) {
                if (openPintuUtama) {
                    let boundary = getBoundaryHWD(pintuUtama);
                    pintuUtama.position.set(-48, 6.5, -75);
                    pintuUtama.rotation.set(0, Math.PI / 2, 0);
                } else {
                    pintuUtama.position.set(-44, 6.5, -70);
                    pintuUtama.rotation.set(0, 0, 0);
                }
            }
        }
        function bukaPintu1() {
            if (pintu1) {
                if (openPintu1) {
                    let boundary = getBoundaryHWD(pintu1);
                    pintu1.position.set(-55, 6.5, -101.5);
                    pintu1.rotation.set(0, Math.PI / 2, 0);
                } else {
                    pintu1.position.set(-59, 6.5, -105.5);
                    pintu1.rotation.set(0, 0, 0);
                }
            }
        }
        function bukaPintu2() {
            if (pintu2) {
                if (openPintu2) {
                    let boundary = getBoundaryHWD(pintu2);
                    pintu2.position.set(-55, 6.5, -144);
                    pintu2.rotation.set(0, Math.PI / 2, 0);
                } else {
                    pintu2.position.set(-59, 6.5, -140);
                    pintu2.rotation.set(0, 0, 0);
                }
            }
        }
        function bukaPintu3() {
            if (pintu3) {
                if (openPintu3) {
                    let boundary = getBoundaryHWD(pintu3);
                    pintu3.position.set(31.2, 6.5, -101.5);
                    pintu3.rotation.set(0, Math.PI / 2, 0);
                } else {
                    pintu3.position.set(35.63, 6.5, -105.5);
                    pintu3.rotation.set(0, 0, 0);
                }
            }
        }

        //#endregion 

        // #region CROSSHAIR HANDLER & ANIMATION
        const crosshair = document.querySelector('.crosshair');
        const focusIndicator = crosshair.querySelector('.focus-indicator');
        let canInteract;
        let interactWith;
        let interactableObject = [];
        // Fungsi untuk memperbarui crosshair
        function updateCrosshair() {
            // Lakukan raycast dari kamera
            if (television, tape1, radio) {
                let index = -1;
                let foundIntersect = false;
                while (index < interactableObject.length - 1 && !foundIntersect) {
                    index++;
                    let element = interactableObject[index];
                    foundIntersect = checkUpdateIntersect(camera, raycaster, element, focusIndicator);
                }
                canInteract = foundIntersect
                if (foundIntersect) {
                    interactWith = interactableObject[index];
                } else {
                    interactWith = null
                }

                // tape highlight
                foundIntersect && interactableObject[index] == tape1 ? applyBrighterMaterial(interactableObject[index], tapeMaterial) : restoreOriginalMaterial(tape1, tapeMaterial);
                foundIntersect && interactableObject[index] == tape2 ? applyBrighterMaterial(interactableObject[index], tapeMaterial) : restoreOriginalMaterial(tape2, tapeMaterial);
                foundIntersect && interactableObject[index] == radio ? applyBrighterMaterial(interactableObject[index], radioMaterial) : restoreOriginalMaterial(radio, radioMaterial);
                foundIntersect && interactableObject[index] == rak_0 ? applyBrighterMaterial(interactableObject[index], rakMaterial) : restoreOriginalMaterial(rak_0, rakMaterial);
                foundIntersect && interactableObject[index] == rak_2 ? applyBrighterMaterial(interactableObject[index], rakMaterial) : restoreOriginalMaterial(rak_2, rakMaterial);
                foundIntersect && interactableObject[index] == rak_3 ? applyBrighterMaterial(interactableObject[index], rakMaterial) : restoreOriginalMaterial(rak_3, rakMaterial);
            }
        }
        function applyBrighterMaterial(object, material) {
            object.traverse(function (child) {
                if (child.isMesh) {
                    child.material = new THREE.MeshStandardMaterial({
                        map: material.map,
                        color: material.color,
                        emissive: material.color,
                        emissiveIntensity: 0.5
                    });
                }
            });
        }
        function restoreOriginalMaterial(object, material) {
            object.traverse(function (child) {
                if (child.isMesh) {
                    child.material = material;
                }
            });
        }
        function interactMovementTween(object, positionTarget, time) {
            const tween = new TWEEN.Tween(object.position)
                .to({ x: positionTarget }, 2000) 
                .easing(TWEEN.Easing.Quadratic.Out) 
                .start();
        }
        function handleInteract() {
            if (keyboard['F'] || keyboard['f']) {
                if (!canInteract) {
                    showAlert(alertContainer, "No interactions possible right now.", "warning")
                } else {
                    console.log(selectedInventory);
                    console.log(inventoryList)
                    if (interactWith === television) {
                        videoOn ? video.pause() : video.play();
                        videoOn = !videoOn;
                        showAlert(alertContainer, "You interact with television", "success")
                    } else if (interactWith == tape1) {
                        setInventoryItem(1, "./public/fototape.png")
                        inventoryList[0] = true;
                        tape1.position.set(0, -10, 0);
                    }  else if (interactWith == tape2) {
                        setInventoryItem(2, "./public/fototape.png")
                        inventoryList[1] = true;
                        tape2.position.set(0, -10, 0);
                    } else if (interactWith == radio) { 
                        if (selectedInventory >= 0 && selectedInventory <= 2 && inventoryList[selectedInventory] == true) {
                            showAlert(alertContainer, "Berhasil", "success")
                        } else {
                            showAlert(alertContainer, "Please select any tape", "warning")
                        }
                    } else if (interactWith == rak_0) {
                        interactMovementTween(rak_0, rak_0_open * 0.1 , 2000);
                        rak_0_open = rak_0_open == 1 ? 0 : 1;
                    } else if (interactWith == rak_2) {
                        interactMovementTween(rak_2, rak_2_open * 0.1, 2000);
                        rak_2_open = rak_2_open == 1 ? 0 : 1;
                    } else if (interactWith == rak_3) {
                        interactMovementTween(rak_3, rak_3_open * 0.1, 2000);
                        rak_3_open = rak_3_open == 1 ? 0 : 1;
                    } 
                }
            }

        }
        // #endregion

        // animate function
        let lastControlUpdateTime = 0;
        const CONTROL_UPDATE_INTERVAL = 0.1; // 0.1 detik
        function animate() {
            requestAnimationFrame(animate);

            TWEEN.update();
            updateSpotlightPosition();
            updateObjectPosition();
            updateCrosshair();
            setInfoBox();
            const currentTime = performance.now() / 1000;
            if (currentTime - lastControlUpdateTime >= CONTROL_UPDATE_INTERVAL) {
                handleInteract();
                specialControl();
                lastControlUpdateTime = currentTime;
            }

            const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;
            for (let i = 0; i < STEPS_PER_FRAME; i++) {
                controls(deltaTime);
                updatePlayer(deltaTime);
                jump = !playerOnFloor;
            }
            control.lock();

            // animasi kipas
            if (kipas) kipas.rotation.y += 0.1;

            // animasi buka pintu utama
            openPintuUtama = (camera.position.x >= -55 && camera.position.x <= -30 && camera.position.z >= -90 && camera.position.z <= -50);
            openPintu2 = (camera.position.x >= -66 && camera.position.x <= -54 && camera.position.z >= -158 && camera.position.z <= -128);
            openPintu1 = (camera.position.x >= -66 && camera.position.x <= -54 && camera.position.z >= -120 && camera.position.z <= -92);
            openPintu3 = (camera.position.x >= 30 && camera.position.x <= 42 && camera.position.z >= -120 && camera.position.z <= -92);
            bukaPintuUtama();
            bukaPintu1(); bukaPintu2(); bukaPintu3();

            garageLight.visible = (camera.position.x >= 30 && camera.position.x <= 95 && camera.position.z >= -105 && camera.position.z <= -40);
            discoLamp.visible = (camera.position.x >= -88 && camera.position.x <= -53 && camera.position.z >= -105 && camera.position.z <= -70);
            
            renderer.render(scene, camera);
        }
        animate();

        function setInfoBox() {
            if (kordinatspan) {
                kordinatspan.textContent = `${Math.round(camera.position.x)}, ${Math.round(camera.position.y)}, ${Math.round(camera.position.z)}`
            }
            if (interactinfospan) {
                interactinfospan.textContent = `${canInteract ? 'TRUE' : 'FALSE'}`;
                interactinfospan.className = `${canInteract ? 'interactTrue' : 'interactFalse'}`
            }
        }
    </script>
</body>

</html>