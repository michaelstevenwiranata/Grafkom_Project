<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PROJECT grafkom</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.153.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.153.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        // utils
        function getBoundaryHWD(object) {
            var boundingBox = new THREE.Box3().setFromObject(object);
            var size = new THREE.Vector3();
            boundingBox.getSize(size);

            // Mendapatkan tinggi, lebar, dan kedalaman
            var height = size.y;
            var width = size.x;
            var depth = size.z;

            return { height, width, depth };
        }
        function getCenterOBJ(object) {
            var boundingBox = new THREE.Box3().setFromObject(object);

            var center = new THREE.Vector3();
            boundingBox.getCenter(center);

            return { ...center }
        }

        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { Octree } from 'three/addons/math/Octree.js';
        import { Capsule } from 'three/addons/math/Capsule.js';
        import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';


        // INITIAL SETUP
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 0);
        camera.rotation.order = 'YXZ';
        const loader = new GLTFLoader();
        const clock = new THREE.Clock();
        const textureLoader = new THREE.TextureLoader();


        const GRAVITY = 30;
        const STEPS_PER_FRAME = 5;
        // player collider
        const worldOctree = new Octree();
        const playerCollider = new Capsule(new THREE.Vector3(0, 0.05, 0), new THREE.Vector3(0, 10, 0), 0.35);
        const playerVelocity = new THREE.Vector3();
        const playerDirection = new THREE.Vector3();

        let playerOnFloor = false;

        const renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0x000000);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.VSMShadowMap;
        document.body.appendChild(renderer.domElement);

        const control = new PointerLockControls(camera, renderer.domElement)

        // LIGHTING
        const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.1, 10, 2);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.1); // Warna putih dengan intensitas 0.5
        directionalLight.position.set(-50, 100, 20);
        scene.add(directionalLight);

        const streetLight1 = new THREE.PointLight(0xffffff, 1000,100,2);
        streetLight1.position.set(-4, 60, -45);
        streetLight1.castShadow = true;
        scene.add(streetLight1);
        streetLight1.shadow.mapSize.width = 512;
        streetLight1.shadow.mapSize.height = 512;
        streetLight1.shadow.bias = -0.005;

        const streetLight2 = new THREE.PointLight(0xffffff, 1000,100,2);
        streetLight2.position.set(14, 60, -60);
        streetLight2.castShadow = true;
        scene.add(streetLight2);
        streetLight2.shadow.mapSize.width = 512;
        streetLight2.shadow.mapSize.height = 512;
        streetLight2.shadow.bias = -0.005;

        // EVENT HANDLING
        let keyboard = {};
        document.addEventListener('keydown', function (event) {
            keyboard[event.key] = true;
        });
        document.addEventListener('keyup', function (event) {
            keyboard[event.key] = false;
        });



        // movement handling
        function controls(deltaTime) {
            const speedDelta = deltaTime * (playerOnFloor ? 20 : 5) + 0.1;
            if (keyboard['W'] || keyboard['w']) {
                playerVelocity.add(getForwardVector().multiplyScalar(speedDelta));
            }
            if (keyboard['a'] || keyboard['A']) {
                playerVelocity.add(getSideVector().multiplyScalar(- speedDelta));
            }
            if (keyboard['s'] || keyboard['S']) {
                playerVelocity.add(getForwardVector().multiplyScalar(- speedDelta));
            }
            if (keyboard['d'] || keyboard['D']) {
                playerVelocity.add(getSideVector().multiplyScalar(speedDelta));
            }
            if (playerOnFloor) {
                if (keyboard['v']) {
                    playerVelocity.y = 15;
                }
            }
        }


        // LOAD MODELS

        let alas, rumah, pintuUtama, streetLamp;
        function objShadow(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        }
        async function loadModels() {
            try {
                // load alas
                const textureAlas = textureLoader.load("./public/grass.jpg");
                textureAlas.wrapS = THREE.RepeatWrapping;
                textureAlas.wrapT = THREE.RepeatWrapping;
                textureAlas.repeat.set(10, 10);
                const alas_geometry = new THREE.BoxGeometry(500, 1, 500);
                const alas_material = new THREE.MeshStandardMaterial({ map: textureAlas });
                alas = new THREE.Mesh(alas_geometry, alas_material);
                alas.position.set(0, 0, 0);

                scene.add(alas);
                worldOctree.fromGraphNode(alas);


                // load rumah
                const ruanganPromise = new Promise((resolve, reject) => {
                    loader.load('./public/rumah.glb', function (gltf) {
                        rumah = gltf.scene;
                        rumah.scale.set(10, 10, 10)
                        rumah.position.set(0, 0, 0);

                        rumah.traverse(objShadow);

                        scene.add(rumah);
                        worldOctree.fromGraphNode(rumah);
                        resolve();
                    }, undefined, reject);
                });
                await ruanganPromise;

                // load pintu depan
                const pintuPromise = new Promise((resolve, reject) => {
                    loader.load('./public/pintuDepan.glb', function (gltf) {
                        pintuUtama = gltf.scene;
                        pintuUtama.scale.set(10, 10, 10)
                        pintuUtama.position.set(-44, 6.5, -70);

                        pintuUtama.traverse(objShadow);

                        scene.add(pintuUtama);
                        resolve();
                    }, undefined, reject);
                });
                await ruanganPromise;

                // load street lamp
                const streetlampPromise = new Promise((resolve, reject) => {
                    loader.load('./public/street_lamp.glb', function (gltf) {
                        streetLamp = gltf.scene;
                        streetLamp.scale.set(10, 15, 10)
                        streetLamp.position.set(-20, -6, -60);

                        streetLamp.traverse(objShadow);

                        scene.add(streetLamp);
                        resolve();
                    }, undefined, reject);
                });
                await streetlampPromise;

                await Promise.all([ruanganPromise, streetlampPromise]);
            } catch (error) {
                console.log("Error loading models : " + error);
            }
        }
        loadModels();

        // COLLISION
        function playerCollisions() {
            const result = worldOctree.capsuleIntersect(playerCollider);
            playerOnFloor = false;
            if (result) {
                playerOnFloor = result.normal.y > 0;
                if (!playerOnFloor) {
                    playerVelocity.addScaledVector(result.normal, - result.normal.dot(playerVelocity));
                }
                playerCollider.translate(result.normal.multiplyScalar(result.depth));
            }
        }
        // buat update player letaknya
        function updatePlayer(deltaTime) {
            let damping = Math.exp(- 4 * deltaTime) - 1;
            if (!playerOnFloor) {
                playerVelocity.y -= GRAVITY * deltaTime;
                damping *= 0.1;
            }
            playerVelocity.addScaledVector(playerVelocity, damping);
            const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
            playerCollider.translate(deltaPosition);
            playerCollisions();
            camera.position.copy(playerCollider.end);
        }
        // dapetin vector arah setelah normalisasi
        function getForwardVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            return playerDirection;
        }
        function getSideVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            playerDirection.cross(camera.up);
            return playerDirection;
        }

        // ANIMATE
        let openPintuUtama = false;
        function bukaPintuUtama() {
            if (pintuUtama) {
                if (openPintuUtama) {
                    let boundary = getBoundaryHWD(pintuUtama);
                    console.log(boundary)
                    pintuUtama.position.set(-48, 6.5, -75);
                    pintuUtama.rotation.set(0, Math.PI / 2, 0);
                } else {
                    pintuUtama.position.set(-44, 6.5, -70);
                    pintuUtama.rotation.set(0, 0, 0);
                }
            }
        }
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;
            for (let i = 0; i < STEPS_PER_FRAME; i++) {
                controls(deltaTime);
                updatePlayer(deltaTime);
            }

            console.log(camera.position);
            control.lock();

            // animasi buka pintu utama
            if (camera.position.x >= -55 && camera.position.x <= -30 && camera.position.z >= -90 && camera.position.z <= -50) {
                openPintuUtama = true;
            } else {
                openPintuUtama = false;
            }
            bukaPintuUtama();


            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>

</html>