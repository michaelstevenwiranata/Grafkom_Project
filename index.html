<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PROJECT grafkom</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <div class="mainInfoBox">
        <span class="mainInfoText"><b>Kordinat : </b><span id="kordinat"></span></span>
        <span class="mainInfoText"><b>Can Interact : </b><span class="interactFalse" style="font-weight: bold;"
                id="interactinfo">FALSE</span></span>
    </div>
    <video id="video_ww" style="display: none;"></video>
    <div id="alert-container"></div>
    <div class="crosshair">
        <div class="vertical"></div>
        <div class="horizontal"></div>
        <div class="focus-indicator">press<span class="characterHighlight"> F </span> to interact</div>
    </div>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.153.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.153.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        let kordinatspan = document.getElementById("kordinat");
        let interactinfospan = document.getElementById("interactinfo");

        // #region IMPORT LIBRARY & FILE
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { Octree } from 'three/addons/math/Octree.js';
        import { Capsule } from 'three/addons/math/Capsule.js';
        import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';
        // utils, helper
        import { checkUpdateIntersect } from "./game.js";
        import { getCenterOBJ, getBoundaryHWD, showAlert } from "./helper.js"
        import { setupLighting } from "./lighting.js"
        // #endregion

        // #region VARIABLE & SETUP
        const scene = new THREE.Scene();
        const raycaster = new THREE.Raycaster();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 0);
        camera.rotation.order = 'YXZ';
        const loader = new GLTFLoader();
        const clock = new THREE.Clock();
        const textureLoader = new THREE.TextureLoader();

        // player component
        const GRAVITY = 30;
        const STEPS_PER_FRAME = 5;
        const worldOctree = new Octree();
        const playerCollider = new Capsule(new THREE.Vector3(0, 0.05, 0), new THREE.Vector3(0, 10, 0), 0.35);
        const playerVelocity = new THREE.Vector3();
        const playerDirection = new THREE.Vector3();
        let playerOnFloor = false;

        // interact & game component
        let video, videoOn = false;
        const alertContainer = document.getElementById('alert-container');

        const renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0x000000);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.VSMShadowMap;
        document.body.appendChild(renderer.domElement);
        const control = new PointerLockControls(camera, renderer.domElement)
        // #endregion

        // #region CENTER LIGHTING
        let wideSpotlight = false;
        const cube = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
        cube.visible = false;
        scene.add(cube);
        function updateObjectPosition() {
            const vector = new THREE.Vector3(0, 0, -10);
            vector.applyMatrix4(camera.matrixWorld);
            cube.position.copy(vector);
        }
        function updateSpotlightPosition() {
            // buat supaya spotlight berada di depan camera
            const offsetDistance = 0;
            const offset = new THREE.Vector3(0, 0, -offsetDistance);
            offset.applyQuaternion(camera.quaternion);
            spotlight.position.copy(camera.position).add(offset);

            // buat ngarahin target spotlight ke posisi cube yang invisible
            spotlight.target.position.copy(cube.position);
            spotlight.target.updateMatrixWorld();
        }

        const spotlight = new THREE.SpotLight(0xffffff, 2);
        spotlight.position.set(0, 5, 10);
        spotlight.angle = Math.PI / 16;
        spotlight.penumbra = 0.1;
        spotlight.decay = 0.1;
        spotlight.distance = 150;

        spotlight.shadow.mapSize.width = 2048; // Meningkatkan resolusi shadow map
        spotlight.shadow.mapSize.height = 2048;
        spotlight.shadow.bias = -0.0001;

        spotlight.castShadow = true;
        scene.add(spotlight);
        // #endregion

        // #region OTHER LIGHTING
        setupLighting(scene, camera)
        // lighting yang nyala dengan kondisi tertentu
        const garageLight = new THREE.PointLight(0xffffff, 500, 1000, 2);
        garageLight.position.set(57, 25, -70);
        garageLight.castShadow = true;
        scene.add(garageLight);
        garageLight.shadow.mapSize.width = 2048;
        garageLight.shadow.mapSize.height = 2048;
        garageLight.shadow.bias = -0.005;

        //disco
        const discoLamp = new THREE.PointLight(0xffffff, 500, 1000, 2.5);
        discoLamp.position.set(-70, 25, -88)
        discoLamp.castShadow = true;
        discoLamp.shadow.mapSize.width = 2048;
        discoLamp.shadow.mapSize.height = 2048;
        discoLamp.shadow.bias = -0.005;
        scene.add(discoLamp)
        // #endregion

        // #region EVENT HANDLING
        let keyboard = {};
        document.addEventListener('keydown', function (event) {
            keyboard[event.key] = true;
        });
        document.addEventListener('keyup', function (event) {
            keyboard[event.key] = false;
        });

        // movement handling
        let jump = false;
        function controls(deltaTime) {
            const speedDelta = deltaTime * (playerOnFloor ? 20 : 5) + 0.1;
            if (keyboard['W'] || keyboard['w']) {
                playerVelocity.add(getForwardVector().multiplyScalar(speedDelta));
            }
            if (keyboard['a'] || keyboard['A']) {
                playerVelocity.add(getSideVector().multiplyScalar(- speedDelta));
            }
            if (keyboard['s'] || keyboard['S']) {
                playerVelocity.add(getForwardVector().multiplyScalar(- speedDelta));
            }
            if (keyboard['d'] || keyboard['D']) {
                playerVelocity.add(getSideVector().multiplyScalar(speedDelta));
            }
            if (keyboard['r'] || keyboard['R']) {
                spotlight.visible = !spotlight.visible;
            }
            if (keyboard['t'] || keyboard['T']) {
                if (wideSpotlight == false) {
                    spotlight.angle = Math.PI / 4;
                    wideSpotlight = true;
                } else {
                    spotlight.angle = Math.PI / 16;
                    wideSpotlight = false;
                }
            }
            if (playerOnFloor) {
                if (keyboard[' ']) {
                    jump = true;
                    playerVelocity.y = 15;
                }
            }
        }
        // #endregion

        // #region LOAD MODELS & VIDEO
        let alas, rumah, pintuUtama, streetLamp1,
            streetLamp2, kipas, sofa, longTable,
            bulan, kasur, pigura, mazda, glight,
            radio, radioTable, disco, television;
        function objShadow(child) {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        }
        async function loadModels() {
            try {
                // load alas
                const textureAlas = textureLoader.load("./public/grass.jpg");
                textureAlas.wrapS = THREE.RepeatWrapping;
                textureAlas.wrapT = THREE.RepeatWrapping;
                textureAlas.repeat.set(10, 10);
                const alas_geometry = new THREE.BoxGeometry(250, 1, 250);
                const alas_material = new THREE.MeshStandardMaterial({ map: textureAlas });
                alas = new THREE.Mesh(alas_geometry, alas_material);
                alas.position.set(0, 0, -80);

                scene.add(alas);
                worldOctree.fromGraphNode(alas);


                // load rumah
                const ruanganPromise = new Promise((resolve, reject) => {
                    loader.load('./public/rumah.glb', function (gltf) {
                        rumah = gltf.scene;
                        rumah.scale.set(10, 10, 10)
                        rumah.position.set(0, 0, 0);

                        rumah.traverse(objShadow);

                        scene.add(rumah);
                        // worldOctree.fromGraphNode(rumah);
                        resolve();
                    }, undefined, reject);
                });
                await ruanganPromise;

                // load pintu depan
                const pintuPromise = new Promise((resolve, reject) => {
                    loader.load('./public/pintuDepan.glb', function (gltf) {
                        pintuUtama = gltf.scene;
                        pintuUtama.scale.set(10, 10, 10)
                        pintuUtama.position.set(-44, 6.5, -70);

                        pintuUtama.traverse(objShadow);
                        scene.add(pintuUtama);
                        resolve();
                    }, undefined, reject);
                });
                await ruanganPromise;

                // load street lamp 1
                const streetlamp1Promise = new Promise((resolve, reject) => {
                    loader.load('./public/street_lamp.glb', function (gltf) {
                        streetLamp1 = gltf.scene;
                        streetLamp1.scale.set(10, 15, 10)
                        streetLamp1.position.set(-20, -6, -60);

                        streetLamp1.traverse(objShadow);

                        scene.add(streetLamp1);
                        resolve();
                    }, undefined, reject);
                });
                await streetlamp1Promise;

                // load street lamp 2
                const streetlamp2Promise = new Promise((resolve, reject) => {
                    loader.load('./public/street_lamp.glb', function (gltf) {
                        streetLamp2 = gltf.scene;
                        streetLamp2.scale.set(10, 15, 10)
                        streetLamp2.position.set(-120, -6, -60);

                        streetLamp2.traverse(objShadow);

                        scene.add(streetLamp2);
                        resolve();
                    }, undefined, reject);
                });
                await streetlamp1Promise;

                // load kipas
                const kipasPromise = new Promise((resolve, reject) => {
                    loader.load('./public/simple_ceiling_fan.glb', function (gltf) {
                        kipas = gltf.scene;
                        kipas.scale.set(0.02, 0.01, 0.02)
                        kipas.position.set(-18, 35.5, -88);

                        kipas.traverse(objShadow);

                        scene.add(kipas);
                        resolve();
                    }, undefined, reject);
                })
                await kipasPromise;

                // load sofa
                const sofaPromise = new Promise((resolve, reject) => {
                    loader.load('./public/sofa.glb', function (gltf) {
                        sofa = gltf.scene;
                        sofa.scale.set(0.1, 0.1, 0.1)
                        sofa.rotation.y = Math.PI;
                        sofa.position.set(-25, 6.5, -88);

                        sofa.traverse(objShadow);

                        worldOctree.fromGraphNode(sofa);
                        scene.add(sofa);
                        resolve();
                    }, undefined, reject);
                })
                await sofaPromise;

                // load long table  
                const longTablePromise = new Promise((resolve, reject) => {
                    loader.load('./public/long_table.glb', function (gltf) {
                        longTable = gltf.scene;
                        longTable.position.set(-3.5, 6, -88);

                        longTable.traverse(objShadow);

                        worldOctree.fromGraphNode(longTable);
                        scene.add(longTable);
                        resolve();
                    }, undefined, reject);
                })
                await longTablePromise;

                // load bulan
                const bulanPromise = new Promise((resolve, reject) => {
                    loader.load('./public/the_moon.glb', function (gltf) {
                        bulan = gltf.scene;
                        bulan.scale.set(10, 10, 10);
                        bulan.position.set(-100, 300, -100);

                        bulan.traverse(objShadow);

                        scene.add(bulan);
                        resolve();
                    }, undefined, reject);
                })
                await bulanPromise;

                // load bed
                const kasurPromise = new Promise((resolve, reject) => {
                    loader.load('./public/bed.glb', function (gltf) {
                        kasur = gltf.scene;
                        kasur.position.set(-78, 6, -168);
                        kasur.scale.set(3, 3, 3);
                        kasur.rotation.y = Math.PI / 2;
                        kasur.traverse(objShadow);

                        worldOctree.fromGraphNode(kasur);
                        scene.add(kasur);
                        resolve();
                    }, undefined, reject);
                })
                await kasurPromise;

                // load  picture frame
                const piguraPromise = new Promise((resolve, reject) => {
                    loader.load('./public/picture.glb', function (gltf) {
                        pigura = gltf.scene;
                        pigura.position.set(-88, 15, -160);
                        pigura.scale.set(1.5, 1.5, 1.5)
                        pigura.rotation.y = Math.PI / 2;
                        pigura.traverse(objShadow);

                        scene.add(pigura);
                        resolve();
                    }, undefined, reject);
                })
                await piguraPromise;

                // load garage light
                const glightPromise = new Promise((resolve, reject) => {
                    loader.load('./public/garage_light.glb', function (gltf) {
                        glight = gltf.scene;
                        glight.position.set(57, 31.85, -70);
                        glight.scale.set(0.01, 0.01, 0.01)
                        glight.traverse(objShadow);

                        scene.add(glight);
                        resolve();
                    }, undefined, reject);
                })
                await glightPromise;

                //load radioTable 
                const radioTablePromise = new Promise((resolve, reject) => {
                    loader.load('./public/table.glb', function (gltf) {
                        radioTable = gltf.scene;
                        radioTable.traverse(objShadow);
                        radioTable.scale.set(2.6, 2.6, 2.6);
                        radioTable.position.set(-70, 7, -88);

                        scene.add(radioTable);
                        resolve();
                    }, undefined, reject);
                })
                await radioTablePromise
                // 
                //load radio
                const radioPromise = new Promise((resolve, reject) => {
                    loader.load('./public/radio_vef202.glb', function (gltf) {
                        radio = gltf.scene;
                        radio.traverse(objShadow);
                        radio.scale.set(1.5, 1.5, 1.5);
                        radio.position.set(-70, 15, -88);
                        radio.rotation.y = Math.PI;

                        scene.add(radio);
                        resolve();
                    }, undefined, reject);
                })
                await radioPromise

                // load disco lamp
                const discoPromise = new Promise((resolve, reject) => {
                    loader.load('./public/disco_ball.glb', function (gltf) {
                        disco = gltf.scene;
                        disco.traverse(objShadow);
                        disco.scale.set(4, 4, 4);
                        disco.position.set(-70, 35, -88);

                        scene.add(disco);
                        resolve();
                    }, undefined, reject);
                })
                await discoPromise

                const televisionPromise = new Promise((resolve, reject) => {
                    loader.load('./public/television.glb', function (gltf) {
                        television = gltf.scene;
                        television.name = "television"
                        television.traverse(objShadow)
                        television.scale.set(20, 20, 20);
                        television.rotation.y = -Math.PI / 2;
                        television.position.set(-5, 12.25, -88);


                        scene.add(television);
                        resolve();
                    }, undefined, reject);
                })
                await televisionPromise

                await Promise.all([ruanganPromise, streetlamp1Promise, streetlamp2Promise,
                    kipasPromise, sofaPromise, longTablePromise, kasurPromise,
                    piguraPromise, glightPromise, radioTablePromise, discoPromise,
                    radioPromise, televisionPromise]);
                // add interactable object;
                interactableObject.push(television)
            } catch (error) {
                console.log("Error loading models : " + error);
            }
        }
        loadModels();
        // load vidio
        video = document.getElementById('video_ww')
        video.src = "public/wutheringwaves.mp4";
        video.muted = false;
        video.loop = false;
        let videoTexture = new THREE.VideoTexture(video);
        const geoLayar = new THREE.PlaneGeometry(2.2255, 1.245); // param1 : lebar, param2 : tinggi unitnya
        const mpmLayar = new THREE.MeshBasicMaterial({ map: videoTexture });
        const layar = new THREE.Mesh(geoLayar, mpmLayar);
        layar.position.set(-5.7, 18.5, -88.25)
        layar.scale.set(7.3, 7.8, 8)
        layar.rotation.set(0, -Math.PI / 2, 0)
        scene.add(layar);

        // #endregion

        // #region COLLISION
        function playerCollisions() {
            const result = worldOctree.capsuleIntersect(playerCollider);
            playerOnFloor = false;
            if (result) {
                playerOnFloor = result.normal.y > 0;
                if (!playerOnFloor) {
                    playerVelocity.addScaledVector(result.normal, - result.normal.dot(playerVelocity));
                }
                playerCollider.translate(result.normal.multiplyScalar(result.depth));
            }
        }
        // buat update player letaknya
        function updatePlayer(deltaTime) {
            let damping = Math.exp(- 4 * deltaTime) - 1;
            if (!playerOnFloor) {
                if (jump) {
                    playerVelocity.y -= GRAVITY * deltaTime;
                    damping *= 0.01;
                } else {
                    playerVelocity.y -= GRAVITY * deltaTime * 0.5;
                }
            }

            playerVelocity.addScaledVector(playerVelocity, damping);
            const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
            playerCollider.translate(deltaPosition);
            playerCollisions();
            camera.position.copy(playerCollider.end);
        }
        // dapetin vector arah setelah normalisasi
        function getForwardVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            return playerDirection;
        }
        function getSideVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            playerDirection.cross(camera.up);
            return playerDirection;
        }
        // #endregion

        // #region ANIMATION
        let openPintuUtama = false;
        const colors = [ "#ff0000", "#ff7f00", "#ffff00", "#7fff00", "#00ff00", "#00ff7f", "#00ffff", "#007fff", "#0000ff", "#7f00ff", "#ff00ff", "#ff007f"];
        let currentColorIndex = 0;

        // Function to change the light color
        function changeColor() {
            discoLamp.color.set(colors[currentColorIndex]);
            currentColorIndex = (currentColorIndex + 1) % colors.length;
        }
        setInterval(changeColor, 1000);

        // animasi buka pintu
        function bukaPintuUtama() {
            if (pintuUtama) {
                if (openPintuUtama) {
                    let boundary = getBoundaryHWD(pintuUtama);
                    console.log(boundary)
                    pintuUtama.position.set(-48, 6.5, -75);
                    pintuUtama.rotation.set(0, Math.PI / 2, 0);
                } else {
                    pintuUtama.position.set(-44, 6.5, -70);
                    pintuUtama.rotation.set(0, 0, 0);
                }
            }
        }
        //#endregion 

        // #region CROSSHAIR HANDLER & ANIMATION
        const crosshair = document.querySelector('.crosshair');
        const focusIndicator = crosshair.querySelector('.focus-indicator');
        let canInteract;
        let interactWith;
        let interactableObject = [];
        // Fungsi untuk memperbarui crosshair
        function updateCrosshair() {
            // Lakukan raycast dari kamera
            if (television) {
                let index = -1;
                let foundIntersect = false;
                while (index < interactableObject.length - 1 && !foundIntersect) {
                    index++;
                    let element = interactableObject[index];
                    foundIntersect = checkUpdateIntersect(camera, raycaster, television, focusIndicator);
                }
                canInteract = foundIntersect
                if (foundIntersect) {
                    interactWith = interactableObject[index];
                } else {
                    interactWith = null
                }
            }
        }
        function handleInteract() {
            if (keyboard['F'] || keyboard['f']) {
                if (!canInteract) {
                    showAlert(alertContainer, "No interactions possible right now.", "warning")
                } else {
                    if (interactWith === television) {
                        videoOn ? video.pause() : video.play();
                        videoOn = !videoOn;
                        showAlert(alertContainer, "You interact with television", "success")
                    }
                }
            }

        }
        // #endregion

        // animate function
        let lastControlUpdateTime = 0;
        const CONTROL_UPDATE_INTERVAL = 0.1; // 0.1 detik
        function animate() {
            requestAnimationFrame(animate);

            updateSpotlightPosition();
            updateObjectPosition();
            updateCrosshair();
            setInfoBox();
            const currentTime = performance.now() / 1000;
            if (currentTime - lastControlUpdateTime >= CONTROL_UPDATE_INTERVAL) {
                handleInteract();
                lastControlUpdateTime = currentTime;
            }

            const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;
            for (let i = 0; i < STEPS_PER_FRAME; i++) {
                controls(deltaTime);
                updatePlayer(deltaTime);
                jump = !playerOnFloor;
            }
            control.lock();

            // animasi kipas
            if (kipas) kipas.rotation.y += 0.1;

            // animasi buka pintu utama
            if (camera.position.x >= -55 && camera.position.x <= -30 && camera.position.z >= -90 && camera.position.z <= -50) {
                openPintuUtama = true;
            } else {
                openPintuUtama = false;
            }
            bukaPintuUtama();

            if (camera.position.x >= 30 && camera.position.x <= 95 && camera.position.z >= -105 && camera.position.z <= -40) {
                garageLight.visible = true;
            } else {
                garageLight.visible = false;
            }

            if (camera.position.x >= -88 && camera.position.x <= -53 && camera.position.z >= -105 && camera.position.z <= -70) {
                discoLamp.visible = true;
            } else {
                discoLamp.visible = false;
            }

            renderer.render(scene, camera);
        }
        animate();

        function setInfoBox() {
            if (kordinatspan) {
                kordinatspan.textContent = `${Math.round(camera.position.x)}, ${Math.round(camera.position.y)}, ${Math.round(camera.position.z)}`
            }
            if (interactinfospan) {
                interactinfospan.textContent = `${canInteract ? 'TRUE' : 'FALSE'}`;
                interactinfospan.className = `${canInteract ? 'interactTrue' : 'interactFalse'}`
            }
        }
    </script>
</body>

</html>